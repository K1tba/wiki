# SSR - путь самурая

Реальный проект cостоит из билда [[React]] приложения и нескольких сервисов бэкенда (сервис авторизации, каталог товаров и т.д.), [[SSL + Nginx|ssl и всё это работает в docker]] .

Каждый сервис работает в [[Docker]] контейнерах, реакт тоже работает в [[Контейнеры Docker|контейнере]] , в котором в качестве сервера используется [[Nginx]] .

Для простоты изложения я буду описывать как будто имеются только 2 сервиса:
1) nginx, отдающий билд реакта (включая css, картинки и вообще всю статику)
2) контейнер с бекендом, у которого есть какой-то API (какой вообще не важно).

Также, я не буду приводить различные директивы docker-compose файла и файлов конфигурации nginx, оставив при этом только важные директивы, отражающие суть происходящего и выкинув всё лишнее.

Поэтому предположим, что [[Nginx]] слушает только только порт 80.

Изначально у меня была следующая конфигурация. [[Nginx]] открывал наружу 80-й порт, контейнер с бэком наружу ничего не открывал. При этом когда требуется обращение к бэку, запрос [[nginx как прокси для nodejs|проксировался через nginx]].

Файл docker-compose.yml был такой:

```yml
services:
	react:
		image: "image/react:1.0.0"
		ports:
			- "80:80"
	backend:
		image: "image/backend:1.0.0"
```

Файл конфигурации nginx был таким:

```
server {
	listen 80;
	
	location / {
		root /usr/share/nginx/html;
		try_files $uri /index.html;
	}
	
	location /api {
		proxy_pass http://backend:3000;
	}
}
```

Здесь надо отметить очень удобную вещь: внутри конфигурационного файла nginx можно указывать хост проксируемого сервиса по имени сервиса из docker-compose файла.

Всё это прекрасно работало, пока не возникла задача организовать SSR. При такой конфигурации при обращении к сайту отдавался "голый" html, а отрисовка шла на клиенте и это надо было исправить.

Дальше я начал вникать в вопросы SSR, почитал статьи на хабре, документацию к react-router и т.д. Везде предлагался подход, который предполагал рендеринг на сервере. Причём это не представлялось какой-то не очень сложной задачей. Так, [в этой статье](https://habr.com/ru/articles/551948/) автор начинает с простого проекта и показывает как отрендерить реакт на сервере. Поначалу всё просто. Затем он говорит: "а если у вас используется роутинг, то надо добавить вот это", потом добавляет: "а если у вас css модули, то добавьте вот это", затем "если у вас react приложение ещё и ajax запросы делает для отрисовки, то добавьте и вот этого" и т.д.

В свою очередь авторы библиотеки [react-router](https://reactrouter.com/en/main) предлагают использовать [Remix](https://remix.run/). Т.е. решений предлагается множество и все они мне не очень нравились. Плюс при таком подходе надо перетащить на сервер babel, инструменты сборки и т.д.

Всё это оптимизма не вызывало, да и вообще идея рендерить реакт на сервере мне не кажется хорошей. Сервер должен решать свои задачи, а не заниматься рендерингом клиентского кода (ну, разве что html разметка для emal-ов или что-то подобное). Поэтому, нужно было найти какое-то другое решение и этим решением стало использование безголового браузера для рендеринга html. В качестве инструмента был выбран Puppeteer.

Ок, раз мы используем [[Puppeteer]] , то надо создать ещё один сервис, который будет получать все запросы, рендерить html и возвращать всё это клиенту. Сам сервис был написан за 5 минут на "чистой" ноде и вот его основная часть:

```js
server.on('request', (req, res) => {
	(async () => {
		const browser = await puppeteer.launch({
			args: ['--no-sandbox', '--disable-setuid-sandbox'],
			headless: 'new'
		});
		const page = await browser.newPage();
		await page.goto(`http://${config.react.host}:${config.react.port}${req.url}`);
		const html = await page.content();
		res.setHeader('content-type', 'text/html; charset=utf-8');
		res.statusCode = 200;
		res.end(html);
		browser.close();
	})();
});
```

Упаковываем этот [[Создание docker контейнера с Puppeteer|сервис в образ]] и вставялем в проект. При этом я создал ещё один контейнер с именем `main` (см. ниже файл docker-compose). Он открывает наружу порт 80 и проксирует запросы. А, контейнер с реакт приложением стал проксируемым.

> Прим.: читай про [[Создание docker контейнера с Puppeteer]]

Теперь docker-compose выглядел так:

```yml
services:
	main:
		image: "nginx"
		ports:
			- "80:80"
	puppeteer:
		image: "image/puppeteer:1.0.0"
	react:
		image: "image/react:1.0.0"
	backend:
		image: "image/backend:1.0.0"
```

Файл конфигурации nginx для сервиса `main`:

```
server {
	listen 80;
	
	location / {
		proxy_pass http://puppeteer:3250;
	}
	
	location /api {
		proxy_pass http://backend:3000;
	}
}
```

Тут надо обратить внимание на то, что сервис `main` не проксирует запросы на контейнер с [[React]] приложением, т.к. запросы к нему делает puppeteer.

Файл конфигурации nginx для сервиса `react` стал таким:

```
server {
	listen 3333;
	
	location / {
		root /usr/share/nginx/html;
		try_files $uri /index.html;
	}
}
```

После запуска выяснилось, что такая комбинация работает не корректно. А именно, как только сервис с puppeteer получал запрос, он адресовал его к сервису `react`, затем получал код, нормально отрисовывал его и возвращал обратно на целевой браузер. При этом, целевой браузер хоть и получал готовый html, но отрисовывал его "криво". Т.к. попутные запросы, которые делает браузер для получения файлов [[CSS стили|css]] , js скриптов, favicon и т.д. также попадали в puppeteer и он их отдавал не корректно. В общем код отображался как будто без стилей, js не работал, а запрос favicon вообще возвращал ошибку 502.

Стало понятно, что когда целевой браузер получает отрендеренный код, то последующие запросы надо отправлять не через puppeteer, а напрямую к сервису со статикой, т.е. к сервису `react`.

Если посмотреть файл `asset-manifrst.json` в папке билда реакта, то можно заметить что все запросы статичных файлов начинаются с `/static`, единственное чего там нет, это запроса favicon. Поэтому вносим изменения в конфигурация nginx сервиса `main`, который обслуживает все запросы из вне:

```
server {

listen 80;

	location / {
		proxy_pass http://puppeteer:3250;
	}
	
	location ~\.js|css|ico|woff2|txt$ {
		proxy_pass http://react:3333;
	}
	
	location ~^/static {
		proxy_pass http://react:3333;
	}
	
	location /api {
		proxy_pass http://backend:3000;
	}
}
```

Теперь, код не ломается. Целевой браузер получив готовый html запрашивает статику в обход [[Puppeteer]] и вроде бы всё хорошо. Но тут вскрылся интересный нюанс. [[React]] приложение после первоначальной отрисовки делает на бэк ajax запросы для наполнения страниц полезным содержимым. И вот это самое содержимое и отсутствовало. Происходило это вот почему: после того как puppeteer получал реакт код от контейнера с реактом (здесь это сервис `react`) и исполнял его у себя, реакт приложение начинало делать ajax запросы к бэку и посылала их обратно к контейнеру от которого был получен код, т.е. к сервису `react`, в свою очередь он ничего не проксировал, а просто отдавал статику. Поэтому на все ajax запросы сервис возвращал index.html и успокаивался на этом. Выяснив это нюанс пришлось допилить конфигурационный файл nginx сервиса `react` так чтобы он проксировал запросы к бэку по аналогии с сервисом `main`.

Финальная конфигурация теперь выглядит так:
docker-compose.yml

```yml
services:
	main:
		image: "nginx"
		ports:
			- "80:80"
	puppeteer:
		image: "image/puppeteer:1.0.0"
	react:
		image: "image/react:1.0.0"
	backend:
		image: "image/backend:1.0.0"
```

конфигурационный файл nginx сервиса `main`:

```
server {

	listen 80;
	
	location / {
		proxy_pass http://puppeteer:3250;
	}
	
	location ~\.js|css|ico|woff2|txt$ {
		proxy_pass http://react:3333;
	}
	
	location ~^/static {
		proxy_pass http://react:3333;
	}
	
	location /api {
		proxy_pass http://backend:3000;
	}
}
```

конфигурационный файл nginx сервиса `react`:

```
server {

	listen 3333;
	
	location / {
		root /usr/share/nginx/html;
		try_files $uri /index.html;
	}
	  
	location /api {
		proxy_pass http://backend:3000;
	}
}
```

Теперь всё работает как надо. Чтобы реализовать SSR оказалось достаточным создать сервис с [[Puppeteer]] на борту и немного поиграть с конфигурационными файлами [[Nginx]] , как по мне это гораздо проще чем рендерить [[React]] на бэке.

Дальше всплывает вопрос по оптимизации ответа сервера, т.к. цепочка получилась длинная, плюс puppeteer ощутимо забирает на себя время, но это уже вопрос кэширования запросов и вообще немного другая история.

#ssr #react #nginx #puppeteer 